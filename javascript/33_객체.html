<!-- 
    절차식 언어 : 위에서 아래로 떨어지는 방식 속도가 빠르다
                 길게 작성하는 방식이기 때문에 공동으로 프로그램을 짜기 힘들다
                 코드 재활용이 쉽지 않다
    자바스크립트는 객체지향과 절차식을 혼용
    -> 객체나 클래스를 대체하는 생성자나 함수같은 기법이 있어 절차식에 객체지향이 가미됨

    객체
    실생활에서 우리가 인식할 수 있는 사물들
    예) 자동차(객체) -> 색상 바퀴개수(명사) 전진 후진(동사)
    
    클래스(설계도) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~> 객체
     명사 -> 변수    클래스를 힙메모리에 올리고 참조변수로 가리킴
     동사 -> 함수  
     => 프로퍼티의 집합으로 구성한다

     * 프로퍼티
       자바스크립트의 기본 타입은 객체이다
       객체란 이름과 값으로 구성된 프로퍼티의 정렬되지 않은 집합이다
       프로퍼티의 값에 함수도 올 수 있는데 이를 프로퍼티 메소드라고 부른다
       const dog = {
           name: "루시" -> 필드(프로퍼티)
           play: function(){..} -> 메소드(프로퍼티 메소드)
       }


    객체를 생성하는 방법
    1. 리터럴 표기법을 이용한 객체 생성
        const 객체이름 = {
            프로퍼티1: 프로퍼티 값1
            ...
        }
    2. 생성자를 이용한 객체의 생성
        new 생성자()를 사용하여 객체를 생성하고 초기화하는데 이때 생성자가 새롭게 생성되는 객체를 초기화하는 역할을 한다
        function 생성자명(매개변수1, 매개변수2, ..){
            프로퍼티명1: 프로퍼티값
            ...
            프로퍼티m명: function() {..}
        }
        const 객체명 = new 생성자명(값1, 값2, ..)
    3. 클래스를 이용한 객체 생성
        ECMA6이후부터 생김
        const 클래스명 = class{
            constructor(매개변수1, 매개변수2, ..){
                프로퍼티1 = 값1
                ...
            }
            메소드명(매개변수1, 매개변수2, .. ){...}
        }
        const 객체명 = new 클래스명(매개변수1, 매개변수2, ..)

        다른 언어의 클래스는 클래스를 파일로 만들어 놓고 객체를 만들때 메모리에 올린다
        자바스크립트에서 클래스는 기존 생성자 함수를 이용하여 객체를 생성한 방법과 동일하게 메소드를 메모리에 미리 올리고 호출해서 사용한다
        즉 내부적으로는 기존 방법과 동일한데 외부적으로만 클래스 형식
        다른 언와 다르게 특이하게 객체를 만들었던 자바스크립트여서 다른 언어와 통일하기 위해 만든 것


    상속
    자바스크립트는 프로토타입 기반의 객체지향 언어이다
    프로토타입 기반이기 때문에 상속의 개념이 클래스기반의 객체지향 언어와는 다르다
    자바스크립트에서는 현재 존재하는 객체의 프로토타입을 사용하여 해당 객체를 복사하고 재사용하는 것을 상속이라고 한다
    즉 자바스크립트에서 상속은 프로토타입을 상속받는것 -> 같은 형태 탬플릿을 물려받는 것 -> 같은 생성자에서 태어난 객체들의 객체이름.prototype이 모두 같다

    * 프로토타입
      자바스크립트의 모든 객체는 프로토타입이라는 객체를 가지고 있다
      모든 객체는 그들의 프로토타입으로부터 프로퍼티와 메소드를 상속받는다
      이 처럼 자바스크립트의 모든 객체는 최소한 하나이상의 다른 객체로부터 상속받으며 상속되는 정보를 제공하는 객체를 프로토타입이라고 한다

      자바스크립트에 내장된 모든 생성자나 사용자지정의 생성자는 Object.prototype과 자신의 생성자 객체를 프로토타입으로 가진다
      Object.prototype은 모든 객체에게 공통된 기능을 제공

      클래스 vs 프로토타입
      클래스는 클래스를 가지고 객체를 생성하는데 프로토타입은 생성자로 객체를 만들면서 객체안에 프로토타입이 만들어 진다
 -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        'use strict'
        //리터럴 표기법으로 객체 생성하기
        const dog = {
            name: "루시",
            family: "포메리안",
            color:"white",
            age: 9,
            weight:2.5
        };
        console.log(dog);
        //객체 안을 접근하려면 "."로 접근
        console.log(dog.name)
        //객체 안을 키값으로 접근할 수 있다
        console.log(dog['name'])
        //반복문으로 불러 올 수 있다
        //i에는 인덱스 대신 키값이 들어간다
        for(let i in dog){
            console.log(i + ": " + dog[i])
        }


        //프로퍼티
        const student = {
            //프로퍼티
            name: "김사과",
            birthday: "19981101",
            hp: "01054038194",
            gender: "여자",
            //프로퍼티 메소드
            makeId: function(){
                return "2020" + this.birthday;
            }
        }
        //함수 실행
        console.log(student.makeId());
        //함수를 변수처럼 사용하여 다른곳으로 넘겨줄 수 있고 이때 함수이름을 활용한다
        console.log(student.makeId);
        

        //생성자를 이용하여 객체 생성하기
        function triangle(b,h){
            this.b = b;
            this.h = h;
            this.area = function(){
                return this.b * this.h / 2;
            }
        }
        const triangle1 = new triangle(15,15)
        console.log(triangle1.b + " " + triangle1.h)
        console.log(triangle1.area())


        //프로토타입
        function Cat(color,name,age){
            this.name = name,
            this.color = color,
            this.age = age
        }

        //자기 객체에 프로퍼티를 추가한다
        let rucy = new Cat("흰색","루시",5);        
        rucy.family = "러시안 블루";
        rucy.breed = function(){
            return this.color + this.family
        }
        console.log("종 "  + rucy.family)
        console.log("품종 " + rucy.breed())

        let ppomi = new Cat("검정","ppomi","길고양이")
        //에러 -> 생성자에는 이 프로퍼티가 없다
        //console.log("종 "  + ppomi.family)
        //console.log("품종 " + ppomi.breed())

        //생성자의 프로퍼티를 변경한다
        Cat.prototype.family = "러시안 블루"
        Cat.prototype.breed = function(){
            return this.color + " " +this.family
        }
        rucy = new Cat("흰색","루시",9)
        ppomi = new Cat("흰섹","뽀미",4)
        console.log("종 "  + rucy.family)
        console.log("품종 " + rucy.breed())
        console.log("종 "  + ppomi.family)
        console.log("품종 " + ppomi.breed())


        //클래스
        const person = class{
            //객체 생서시 자동으로 실행되는 함수
            //생성자 함수와 동일한 기능
            constructor(name,age,sex){
                this.name = name
                this.age = age
                this.sex = sex
            }
            walk(){
                return this.name + "이 걷는다"
            }
        }
        const seobin = new person("서빈",23,"여자")
        for(let i in seobin){
            console.log(seobin[i])
        }
        console.log(seobin.walk())
        seobin.age = 24
        console.log(seobin.age)
    </script> 
</body>
</html>